import json
import time
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, List, Optional, Union

import bittensor as bt
import numpy as np

from gas.cache.content_db import ContentDB
from gas.cache.media_storage import MediaStorage
from gas.cache.types import Media, MediaEntry, PromptEntry
from gas.cache.util import extract_media_info, get_format_from_content
from gas.types import MediaType, Modality


class ContentManager:
    """
    Unified interface for managing content storage and retrieval.

    This class encapsulates both filesystem and database operations,
    providing high-level methods like write_media() and write_prompt().
    """

    def __init__(self, base_dir: Optional[Path] = None):
        """
        Initialize the content manager.

        Args:
            base_dir: Base directory for cache storage (defaults to ~/.cache/sn34)
        """
        if base_dir is None:
            base_dir = Path("~/.cache/sn34").expanduser()

        self.base_dir = Path(base_dir)
        self.content_db = ContentDB(self.base_dir / "prompts.db")
        self.media_storage = MediaStorage(self.base_dir)

    def write_prompt(
        self,
        content: str,
        content_type: str = "prompt",
        source_media_id: Optional[str] = None
    ) -> str:
        """
        Write a prompt to the database.

        Args:
            content: The prompt or search query text
            content_type: Either "prompt" or "search_query"
            source_media_id: Media id if prompt was generated by a VLM
        Returns:
            The ID of the created prompt entry
        """
        try:
            prompt_id = self.content_db.add_prompt_entry(
                content=content,
                content_type=content_type,
                source_media_id=source_media_id
            )
            bt.logging.debug(f"Added {content_type} to database with ID: {prompt_id}")
            return prompt_id
        except Exception as e:
            bt.logging.error(f"Error writing {content_type} to database: {e}")
            raise

    def write_generated_media(
        self,
        modality: Modality,
        media_type: MediaType,
        model_name: str,
        prompt_id: str,
        media_content: Any,
        mask_content: Optional[np.ndarray] = None,
        generation_args: Optional[Dict[str, Any]] = None,
    ) -> Optional[str]:
        """
        Write generated media (from models) to storage.

        Args:
            modality: Modality.IMAGE or Modality.VIDEO
            media_type: MediaType.REAL, MediaType.SYNTHETIC, or MediaType.SEMISYNTHETIC
            model_name: Name of the model that generated this media
            prompt_id: ID of the associated prompt
            media_content: The media content (PIL Image, video frames, etc.)
            mask_content: Optional mask for images
            generation_args: args used in generating this media
        Returns:
            Path to the saved media file, or None if failed
        """
        try:
            # Determine format from content type
            format = get_format_from_content(media_content, modality)

            media_data = Media(
                modality=modality,
                media_type=media_type,
                prompt_id=prompt_id,
                media_content=media_content,
                format=format,
                model_name=model_name,
                mask_content=mask_content,
                generation_args=generation_args
            )

            # Use MediaStorage to handle filesystem operations
            save_path, mask_path = self.media_storage.write_media(media_data)

            if save_path is None:
                bt.logging.error("Failed to write media to filesystem")
                return None

            # Extract metadata from the saved file using filesystem utils
            resolution, file_size = extract_media_info(save_path, media_data.modality)

            # Add entry to database
            media_id = self.content_db.add_media_entry(
                prompt_id=media_data.prompt_id,
                file_path=save_path,
                modality=media_data.modality,
                media_type=media_data.media_type,
                source_type="generated",
                generation_args=generation_args,
                model_name=media_data.model_name,
                mask_path=mask_path,
                timestamp=int(time.time()),
                resolution=resolution,
                file_size=file_size,
                format=media_data.format,
            )

            bt.logging.info(f"Saved media to {save_path} with database ID: {media_id}")
            return save_path

        except Exception as e:
            bt.logging.error(f"Error writing media: {e}")
            return None

    def write_scraped_media(
        self,
        modality: Modality,
        media_type: MediaType,
        prompt_id: str,
        media_content: Any,
        download_url: str,
        scraper_name: str,
        mask_content: Optional[np.ndarray] = None,
        resolution: Optional[tuple[int, int]] = None,
    ) -> Optional[str]:
        """
        Write scraped media (from web sources) to storage.

        Args:
            modality: Modality.IMAGE or Modality.VIDEO
            media_type: MediaType.REAL or MediaType.SEMISYNTHETIC
            prompt_id: ID of the associated search query
            media_content: The media content (PIL Image, video frames, etc.)
            download_url: URL where the media was scraped from
            scraper_name: Name of the scraper (e.g., 'google', 'bing')
            mask_content: Optional mask for images
            resolution: Optional (width, height) tuple

        Returns:
            Path to the saved media file, or None if failed
        """

        media_data = Media(
            modality=modality,
            media_type=media_type,
            prompt_id=prompt_id,
            media_content=media_content,
            format=get_format_from_content(media_content, modality),
            model_name=None,  # Not applicable for scraped media
            mask_content=mask_content,
        )

        # Use MediaStorage to handle filesystem operations
        save_path, mask_path = self.media_storage.write_media(media_data)

        if save_path is None:
            bt.logging.error("Failed to write scraped media to filesystem")
            return None

        # Extract metadata from the saved file using filesystem utils
        # Use provided resolution if available, otherwise extract from file
        if resolution is None:
            resolution, file_size = extract_media_info(save_path, media_data.modality)
        else:
            file_size = extract_media_info(save_path, media_data.modality)[1]

        # Add entry to database with source_type='scraper'
        media_id = self.content_db.add_media_entry(
            prompt_id=media_data.prompt_id,
            file_path=save_path,
            modality=media_data.modality,
            media_type=media_data.media_type,
            source_type="scraper",
            download_url=download_url,
            scraper_name=scraper_name,
            mask_path=mask_path,
            timestamp=int(time.time()),
            resolution=resolution,
            file_size=file_size,
            format=media_data.format,
        )

        bt.logging.info(
            f"Saved scraped media to {save_path} with database ID: {media_id}"
        )
        return save_path

    def write_dataset_media(
        self,
        modality: Modality,
        media_type: MediaType,
        media_content: Any,
        dataset_name: str,
        dataset_source_file: str,
        dataset_index: str,
        mask_content: Optional[np.ndarray] = None,
        resolution: Optional[tuple[int, int]] = None,
    ) -> Optional[str]:
        """
        Write dataset media (from HuggingFace datasets) to storage.

        Args:
            modality: Modality.IMAGE or Modality.VIDEO
            media_type: MediaType.REAL (datasets are real media)
            media_content: The media content (bytes, PIL Image, etc.)
            dataset_name: Name/path of the dataset (e.g., 'laion/laion2B-en')
            dataset_source_file: Source file within dataset (e.g., 'data_001.parquet')
            dataset_index: Index within the dataset file
            mask_content: Optional mask for images
            resolution: Optional (width, height) tuple

        Returns:
            Path to the saved media file, or None if failed
        """

        media_data = Media(
            modality=modality,
            media_type=media_type,
            prompt_id=None,  # Dataset media is not tied to prompts
            media_content=media_content,
            format=get_format_from_content(media_content, modality),
            model_name=None,  # Not applicable for dataset media
            mask_content=mask_content,
        )

        # Use MediaStorage to handle filesystem operations
        save_path, mask_path = self.media_storage.write_media(media_data)

        if save_path is None:
            bt.logging.error("Failed to write dataset media to filesystem")
            return None

        # Extract metadata from the saved file using filesystem utils
        # Use provided resolution if available, otherwise extract from file
        if resolution is None:
            resolution, file_size = extract_media_info(save_path, media_data.modality)
        else:
            file_size = extract_media_info(save_path, media_data.modality)[1]

        # Add entry to database with source_type='dataset'
        media_id = self.content_db.add_media_entry(
            prompt_id=None,  # Dataset media is not tied to prompts
            file_path=save_path,
            modality=media_data.modality,
            media_type=media_data.media_type,
            source_type="dataset",
            dataset_name=dataset_name,
            dataset_source_file=dataset_source_file,
            dataset_index=dataset_index,
            mask_path=mask_path,
            timestamp=int(time.time()),
            resolution=resolution,
            file_size=file_size,
            format=media_data.format,
        )

        bt.logging.info(
            f"Saved dataset media to {save_path} with database ID: {media_id}"
        )
        return save_path

    def sample_prompts(
        self, k: int = 1, remove: bool = True, strategy: str = "random"
    ) -> List[PromptEntry]:
        """
        Sample prompts from the database.

        Args:
            k: Number of prompts to sample
            remove: Whether to mark prompts as used
            strategy: Sampling strategy

        Returns:
            List of PromptEntry objects
        """
        return self.content_db.sample_prompt_entries(
            k=k, remove=remove, strategy=strategy
        )

    def sample_search_queries(
        self, k: int = 1, remove: bool = False, strategy: str = "random"
    ) -> List[PromptEntry]:
        """
        Sample search queries from the database.

        Args:
            k: Number of queries to sample
            remove: Whether to mark queries as used
            strategy: Sampling strategy

        Returns:
            List of PromptEntry objects
        """
        return self.content_db.sample_prompt_entries(
            k=k, content_type="search_query", remove=remove, strategy=strategy
        )

    def sample_prompts_with_source_media(
        self,
        k: int = 1,
        remove: bool = True,
        strategy: str = "random",
        **kwargs
    ) -> List[Dict[str, Any]]:
        """
        Sample prompts from the database and load their associated source media content.

        Args:
            k: Number of prompts to sample
            remove: Whether to mark prompts as used
            strategy: Sampling strategy
            **kwargs: Additional arguments for reading media

        Returns:
            List of dictionaries containing prompt entries and their source media content
        """
        # Sample prompts that have source media
        prompt_entries = self.content_db.sample_prompt_entries(
            k=k,
            remove=remove,
            strategy=strategy
        )

        results = []
        for prompt in prompt_entries:
            if not prompt.source_media_id:
                continue

            media_entries = self.content_db.get_media_entries(
                media_id=prompt.source_media_id
            )
            
            if media_entries:
                media_content = self.media_storage.retrieve_media(
                    media_entries=media_entries,
                    modality=Modality.IMAGE,
                    **kwargs
                )
                
                if media_content["count"] > 0:
                    results.append({
                        "prompt": prompt,
                        "media": media_content["items"][0]
                    })

        return results

    def sample_media(
        self,
        k: int = 1,
        modality: Modality = Modality.IMAGE,
        media_type: MediaType = MediaType.SYNTHETIC,
        remove: bool = False,
        strategy: str = "random",
    ) -> List[MediaEntry]:
        """
        Sample media entries from the database.

        Args:
            k: Number of media entries to sample
            modality: Modality.IMAGE or Modality.VIDEO
            media_type: MediaType.REAL, MediaType.SYNTHETIC, or MediaType.SEMISYNTHETIC
            remove: Whether to mark associated prompts as used
            strategy: Sampling strategy

        Returns:
            List of MediaEntry objects
        """
        return self.content_db.sample_media_entries(
            k=k,
            modality=modality,
            media_type=media_type,
            remove=remove,
            strategy=strategy,
        )

    def sample_media_with_content(
        self,
        modality: Modality,
        media_type: MediaType,
        count: int = 1,
        remove_from_cache: bool = False,
        **kwargs,
    ) -> Optional[Dict[str, Any]]:
        """
        Sample media from database and load the actual content from filesystem.

        Args:
            modality: The modality (Modality.IMAGE or Modality.VIDEO)
            media_type: The media type (MediaType.REAL, MediaType.SYNTHETIC, or MediaType.SEMISYNTHETIC)
            count: Number of items to sample
            remove_from_cache: Whether to remove sampled items from cache
            **kwargs: Additional arguments for reading media

        Returns:
            Dictionary with sampled items or None if no items available
        """
        media_entries = self.content_db.sample_media_entries(
            k=count,
            modality=modality,
            media_type=media_type,
            remove=remove_from_cache,
            strategy=kwargs.get("strategy", "random"),
        )

        if not media_entries:
            print(f"No media available in database for {modality}/{media_type}")
            return {'count': 0, 'items': []}

        media_results = self.media_storage.retrieve_media(
            media_entries=media_entries,
            modality=modality,
            remove_from_cache=remove_from_cache,
            **kwargs,
        )['items']

        for media, db_entry in zip(media_results, media_entries):        
            media['id'] = db_entry.id
            media['metadata'] = db_entry.to_dict()

        return {'count': len(media_results), 'items': media_results}

    def get_media_entry_by_file_path(self, file_path: str) -> Optional[MediaEntry]:
        """
        Args:
            file_path: Path to the media file

        Returns:
            MediaEntry object or None if not found
        """
        return self.content_db.get_media_entry_by_file_path(file_path)

    def delete_media_by_file_path(self, file_path: str) -> bool:
        """
        Delete a media file and its database entry.

        Args:
            file_path: Path to the media file

        Returns:
            True if successful, False otherwise
        """
        try:
            # Delete from filesystem
            file_path_obj = Path(file_path)
            if file_path_obj.exists():
                success = self.media_storage.delete_media_file(file_path_obj)
                if not success:
                    return False

            # Delete from database
            return self.content_db.delete_media_entry_by_file_path(file_path)

        except Exception as e:
            bt.logging.error(f"Error deleting media {file_path}: {e}")
            return False

    def get_stats(self) -> Dict[str, Any]:
        return self.content_db.get_stats()

    def get_dataset_media_counts(self) -> Dict[str, int]:
        """
        Get counts of dataset media entries (NULL prompt_id) by modality and media type.

        Returns:
            Dictionary with counts for each modality/media_type combination
        """
        return self.content_db.get_dataset_media_counts()
